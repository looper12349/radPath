<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RadPath Explorer - Safe Path in a Radioactive Labyrinth</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
<style>
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(66, 153, 225, 0.9); transform: scale(1); }
  50% { box-shadow: 0 0 0 15px rgba(66, 153, 225, 0.4); transform: scale(1.1); }
  100% { box-shadow: 0 0 0 0 rgba(66, 153, 225, 0); transform: scale(1); }
}

.path-cell {
  animation: pulse 1.5s infinite;
  z-index: 20;
  position: relative;
}

.path-connector {
  position: absolute;
  background-color: #3182ce;
  z-index: 10;
  transform-origin: 0 50%;
}

.grid-cell {
  transition: all 0.3s ease-in-out;
}

.grid-cell:hover {
  transform: scale(1.05);
  z-index: 10;
}

.radiation-0-20 { background-color: #9ae6b4; }
.radiation-21-40 { background-color: #68d391; }
.radiation-41-60 { background-color: #faf089; }
.radiation-61-80 { background-color: #f6ad55; }
.radiation-81-100 { background-color: #fc8181; }
.radiation-100-plus { background-color: #e53e3e; }
</style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
<div class="container mx-auto px-4 py-8">
<!-- Header -->
<header class="text-center mb-8">
  <h1 class="text-4xl md:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-teal-400 mb-4">RadPath Explorer</h1>
  <p class="text-gray-300 max-w-2xl mx-auto">Navigate through a radioactive labyrinth finding the safest path with minimal radiation exposure</p>
</header>

<!-- Controls -->
<div class="bg-gray-800 rounded-lg p-6 shadow-lg mb-8">
  <div class="flex flex-col md:flex-row items-center justify-between">
    <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mb-4 md:mb-0">
      <div>
        <label for="gridSizeN" class="block text-sm font-medium text-gray-300 mb-1">Grid Height (N):</label>
        <input type="number" id="gridSizeN" min="2" max="10" value="3" class="bg-gray-700 text-white rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 w-24">
      </div>
      <div>
        <label for="gridSizeM" class="block text-sm font-medium text-gray-300 mb-1">Grid Width (M):</label>
        <input type="number" id="gridSizeM" min="2" max="10" value="3" class="bg-gray-700 text-white rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 w-24">
      </div>
      <div>
        <label for="editModeToggle" class="block text-sm font-medium text-gray-300 mb-1">Edit Mode:</label>
        <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
          <input type="checkbox" id="editModeToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
          <label for="editModeToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-700 cursor-pointer"></label>
        </div>
        <span id="editModeStatus" class="text-xs text-gray-400">Off</span>
      </div>
    </div>
    <div class="flex space-x-3">
      <button id="generateBtn" class="bg-gradient-to-r from-blue-500 to-teal-500 hover:from-blue-600 hover:to-teal-600 text-white px-6 py-2 rounded-lg font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">Generate Grid</button>
      <button id="resetBtn" class="bg-gray-700 hover:bg-gray-600 text-white px-6 py-2 rounded-lg font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">Reset</button>
    </div>
  </div>

  <div class="mt-4">
    <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4">
      <div>
        <label for="animationSpeed" class="block text-sm font-medium text-gray-300 mb-1">Animation Speed:</label>
        <input type="range" id="animationSpeed" min="1" max="10" value="5" class="bg-gray-700 rounded w-full">
      </div>
      <div class="flex space-x-2">
        <button id="playBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium focus:outline-none focus:ring-2 focus:ring-green-500 transition-all">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </button>
        <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-lg font-medium focus:outline-none focus:ring-2 focus:ring-yellow-500 transition-all">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </button>
        <button id="stepBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Main content -->
<div class="flex flex-col lg:flex-row gap-8">
  <!-- Grid Visualization -->
  <div class="lg:w-2/3">
    <div class="bg-gray-800 rounded-lg p-6 shadow-lg h-full">
      <h2 class="text-xl font-semibold mb-4">Grid Visualization</h2>
      <div class="grid-container overflow-auto" style="max-height: 600px;">
        <div id="gridView" class="grid gap-1 mx-auto"></div>
      </div>
    </div>
  </div>

  <!-- Information Panel -->
  <div class="lg:w-1/3">
    <div class="bg-gray-800 rounded-lg p-6 shadow-lg mb-8">
      <h2 class="text-xl font-semibold mb-4">Results</h2>
      <div class="flex items-center space-x-2 mb-4">
        <span class="text-gray-300">Minimum max radiation:</span>
        <span id="minMaxRadiation" class="text-2xl font-bold text-blue-400">-</span>
      </div>
      <div id="pathDisplay" class="hidden">
        <h3 class="text-lg font-medium mb-2">Optimal Path</h3>
        <div id="pathSteps" class="text-sm text-gray-300"></div>
      </div>
    </div>

    <div class="bg-gray-800 rounded-lg p-6 shadow-lg">
      <h2 class="text-xl font-semibold mb-4">About the Algorithm</h2>
      <div class="text-gray-300 text-sm space-y-3">
        <p>The <span class="font-medium text-blue-400">Safe Path</span> algorithm finds the path from the top-left to the bottom-right of a grid that minimizes the maximum radiation encountered.</p>
        <p>This is solved using a binary search combined with BFS (Breadth-First Search) to efficiently find the optimal path.</p>
        
        <h3 class="text-lg font-medium mt-4 mb-2">Radiation Level Legend</h3>
        <div class="grid grid-cols-2 gap-2">
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-green-300 mr-2"></div>
            <span>0-20: Safe</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-green-500 mr-2"></div>
            <span>21-40: Low</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-yellow-200 mr-2"></div>
            <span>41-60: Medium</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-orange-400 mr-2"></div>
            <span>61-80: High</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-red-400 mr-2"></div>
            <span>81-100: Very High</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 rounded-sm bg-red-600 mr-2"></div>
            <span>100+: Extreme</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Elements
  const gridSizeN = document.getElementById('gridSizeN');
  const gridSizeM = document.getElementById('gridSizeM');
  const generateBtn = document.getElementById('generateBtn');
  const resetBtn = document.getElementById('resetBtn');
  const gridView = document.getElementById('gridView');
  const minMaxRadiationEl = document.getElementById('minMaxRadiation');
  const pathStepsEl = document.getElementById('pathSteps');
  const pathDisplayEl = document.getElementById('pathDisplay');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const animationSpeed = document.getElementById('animationSpeed');

  // Variables
  let grid = [];
  let path = [];
  let isAnimating = false;
  let animationInterval = null;
  let currentStep = 0;
  let editMode = false;
  
  // Initialize grid
  generateGrid();

  // Event listeners
  generateBtn.addEventListener('click', generateGrid);
  resetBtn.addEventListener('click', resetGrid);
  playBtn.addEventListener('click', startAnimation);
  pauseBtn.addEventListener('click', pauseAnimation);
  stepBtn.addEventListener('click', stepAnimation);
  
  // Edit mode toggle
  const editModeToggle = document.getElementById('editModeToggle');
  const editModeStatus = document.getElementById('editModeStatus');
  
  editModeToggle.addEventListener('change', function() {
    editMode = this.checked;
    editModeStatus.textContent = editMode ? 'On' : 'Off';
    editModeStatus.className = editMode ? 'text-xs text-green-400' : 'text-xs text-gray-400';
    
    // Update grid cells to be editable or not
    updateCellEditability();
  });

  // Functions
  function getRadiationClass(value) {
    if (value <= 20) return 'radiation-0-20';
    if (value <= 40) return 'radiation-21-40';
    if (value <= 60) return 'radiation-41-60';
    if (value <= 80) return 'radiation-61-80';
    if (value <= 100) return 'radiation-81-100';
    return 'radiation-100-plus';
  }

  function generateGrid() {
    const n = parseInt(gridSizeN.value);
    const m = parseInt(gridSizeM.value);
    
    // Validate input
    if (n < 2 || m < 2 || n > 10 || m > 10) {
      alert('Grid size must be between 2 and 10');
      return;
    }

    // Create grid with random radiation values
    grid = Array(n).fill().map(() => 
      Array(m).fill().map(() => Math.floor(Math.random() * 100) + 1)
    );

    // Update sample grid with first example if 3x3
    if (n === 3 && m === 3) {
      grid = [
        [1, 3, 5],
        [2, 8, 2],
        [4, 2, 1]
      ];
    }

    renderGrid();
    solveMazeAndVisualize();
  }


  function updateCellEditability() {
    Array.from(gridView.children).forEach(cell => {
      if (cell.classList.contains('path-connector')) return;
      
      if (editMode) {
        cell.classList.add('edit-mode-cell');
        
        // Make the cell clickable for editing
        cell.onclick = function() {
          // Only allow editing if not currently animating
          if (isAnimating) return;
          
          const row = parseInt(this.dataset.row);
          const col = parseInt(this.dataset.col);
          
          // Create input for editing
          const value = grid[row][col];
          const currentContent = this.textContent;
          
          // Clear the cell content
          const originalHTML = this.innerHTML;
          this.innerHTML = '';
          
          // Create input element
          const input = document.createElement('input');
          input.type = 'number';
          input.min = '1';
          input.max = '999';
          input.value = value;
          input.className = 'cell-input bg-gray-700';
          this.appendChild(input);
          
          // Focus the input
          input.focus();
          
          // Handle input blur (when user clicks away)
          input.onblur = function() {
            const newValue = parseInt(this.value);
            
            // Validate input
            if (!isNaN(newValue) && newValue > 0) {
              grid[row][col] = newValue;
              cell.textContent = newValue;
              
              // Update the cell color based on new radiation value
              const radiationClass = getRadiationClass(newValue);
              
              // Reset classes but keep edit-mode-cell
              cell.className = `grid-cell ${radiationClass} flex items-center justify-center font-medium h-12 w-full rounded-md relative edit-mode-cell`;
              
              // Re-add start/end styles if needed
              if (row === 0 && col === 0) {
                cell.classList.add('ring-2', 'ring-blue-500');
                cell.innerHTML = `${newValue}<div class="absolute -top-2 -left-2 bg-blue-500 text-xs rounded-full p-1">S</div>`;
              } else if (row === grid.length-1 && col === grid[0].length-1) {
                cell.classList.add('ring-2', 'ring-green-500');
                cell.innerHTML = `${newValue}<div class="absolute -bottom-2 -right-2 bg-green-500 text-xs rounded-full p-1">E</div>`;
              }
              
              // Recalculate the path with the new grid
              path = [];
              currentStep = 0;
              clearHighlights();
              solveMazeAndVisualize();
            } else {
              // If invalid, revert to original value
              cell.innerHTML = originalHTML;
            }
          };
          
          // Handle Enter key
          input.onkeydown = function(e) {
            if (e.key === 'Enter') {
              this.blur();
            }
          };
        };
      } else {
        cell.classList.remove('edit-mode-cell');
        cell.onclick = null;
      }
    });
  }

  function renderGrid() {
    gridView.innerHTML = '';
    const n = grid.length;
    const m = grid[0].length;
    
    // Set grid template columns based on grid size
    gridView.style.gridTemplateColumns = `repeat(${m}, minmax(40px, 60px))`;
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < m; j++) {
        const cell = document.createElement('div');
        const value = grid[i][j];
        
        cell.className = `grid-cell ${getRadiationClass(value)} flex items-center justify-center font-medium h-12 w-full rounded-md relative`;
        cell.textContent = value;
        cell.dataset.row = i;
        cell.dataset.col = j;
        
        // Highlight start and end positions
        if (i === 0 && j === 0) {
          cell.classList.add('ring-2', 'ring-blue-500');
          cell.innerHTML += `<div class="absolute -top-2 -left-2 bg-blue-500 text-xs rounded-full p-1">S</div>`;
        }
        if (i === n-1 && j === m-1) {
          cell.classList.add('ring-2', 'ring-green-500');
          cell.innerHTML += `<div class="absolute -bottom-2 -right-2 bg-green-500 text-xs rounded-full p-1">E</div>`;
        }
        
        gridView.appendChild(cell);
      }
    }
  }

  function resetGrid() {
    pauseAnimation();
    currentStep = 0;
    path = [];
    pathDisplayEl.classList.add('hidden');
    minMaxRadiationEl.textContent = '-';
    pathStepsEl.innerHTML = '';
    renderGrid();
  }

  function solveMazeAndVisualize() {
    const result = findSafePath(grid);
    minMaxRadiationEl.textContent = result.minMaxRadiation !== Infinity ? result.minMaxRadiation : '-1';
    
    path = result.path;
    pathDisplayEl.classList.toggle('hidden', !path.length);
    
    if (path.length) {
      pathStepsEl.innerHTML = path.map((p, idx) => 
        `<div class="mb-1">${idx+1}. (${p.x}, ${p.y}) - Radiation: ${grid[p.x][p.y]}</div>`
      ).join('');
    }
  }

  function findSafePath(grid) {
    const n = grid.length;
    const m = grid[0].length;
    
    // Edge case: empty grid
    if (n === 0 || m === 0) return { minMaxRadiation: -1, path: [] };
    
    // Get all unique radiation values in sorted order
    const radiationValues = [...new Set(grid.flat())].sort((a, b) => a - b);
    
    let left = 0;
    let right = radiationValues.length - 1;
    let result = { minMaxRadiation: Infinity, path: [] };
    
    // Binary search on radiation values
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const maxRadiation = radiationValues[mid];
      
      // Check if path exists with radiation levels <= maxRadiation
      const bfsResult = bfs(grid, maxRadiation);
      
      if (bfsResult.found) {
        result = {
          minMaxRadiation: maxRadiation,
          path: bfsResult.path
        };
        right = mid - 1; // Try to find a better (lower) radiation level
      } else {
        left = mid + 1; // Need to allow higher radiation level
      }
    }
    
    return result;
  }

  function bfs(grid, maxRadiation) {
    const n = grid.length;
    const m = grid[0].length;
    
    // If start or end positions have radiation higher than allowed, no path exists
    if (grid[0][0] > maxRadiation || grid[n-1][m-1] > maxRadiation) {
      return { found: false, path: [] };
    }
    
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
    const visited = Array(n).fill().map(() => Array(m).fill(false));
    const parent = Array(n).fill().map(() => Array(m).fill(null));
    
    const queue = [{x: 0, y: 0}];
    visited[0][0] = true;
    
    while (queue.length > 0) {
      const {x, y} = queue.shift();
      
      // Reached the target
      if (x === n-1 && y === m-1) {
        return {
          found: true,
          path: reconstructPath(parent, n-1, m-1)
        };
      }
      
      // Try all four directions
      for (const [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        
        // Check if the new position is valid
        if (nx >= 0 && nx < n && ny >= 0 && ny < m && 
            !visited[nx][ny] && grid[nx][ny] <= maxRadiation) {
          visited[nx][ny] = true;
          parent[nx][ny] = {x, y};
          queue.push({x: nx, y: ny});
        }
      }
    }
    
    return { found: false, path: [] };
  }

  function reconstructPath(parent, x, y) {
    const path = [];
    
    // Start from the end point and follow parent pointers
    let current = {x, y};
    while (current !== null) {
      path.unshift(current);
      if (current.x === 0 && current.y === 0) break;
      current = parent[current.x][current.y];
    }
    
    return path;
  }

  function createPathConnector(fromX, fromY, toX, toY) {
    // Find the cells
    const fromCell = Array.from(gridView.children).find(
      el => parseInt(el.dataset.row) === fromX && parseInt(el.dataset.col) === fromY
    );
    
    const toCell = Array.from(gridView.children).find(
      el => parseInt(el.dataset.row) === toX && parseInt(el.dataset.col) === toY
    );
    
    if (!fromCell || !toCell) return;
    
    // Get cell positions
    const fromRect = fromCell.getBoundingClientRect();
    const toRect = toCell.getBoundingClientRect();
    const gridRect = gridView.getBoundingClientRect();
    
    // Calculate center points relative to grid container
    const fromCenterX = fromRect.left + fromRect.width/2 - gridRect.left;
    const fromCenterY = fromRect.top + fromRect.height/2 - gridRect.top;
    const toCenterX = toRect.left + toRect.width/2 - gridRect.left;
    const toCenterY = toRect.top + toRect.height/2 - gridRect.top;
    
    // Calculate length and angle
    const dx = toCenterX - fromCenterX;
    const dy = toCenterY - fromCenterY;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    // Create connector
    const connector = document.createElement('div');
    connector.className = 'path-connector';
    connector.style.width = `${length}px`;
    connector.style.height = '4px';
    connector.style.left = `${fromCenterX}px`;
    connector.style.top = `${fromCenterY - 2}px`;
    connector.style.transform = `rotate(${angle}deg)`;
    connector.style.borderRadius = '2px';
    connector.style.opacity = '0.7';
    
    connector.dataset.from = `${fromX}-${fromY}`;
    connector.dataset.to = `${toX}-${toY}`;
    
    // Add to grid
    gridView.appendChild(connector);
  }

  function highlightCell(x, y, isPath = false, prevX = null, prevY = null) {
    const cell = Array.from(gridView.children).find(
      el => parseInt(el.dataset.row) === x && parseInt(el.dataset.col) === y
    );
    
    if (cell) {
      if (isPath) {
        // Apply distinct styling for path cells
        cell.classList.add('path-cell', 'ring-4', 'ring-blue-500', 'z-10');
        // Add a blue background overlay to make path cells stand out
        cell.style.backgroundColor = 'rgba(59, 130, 246, 0.7)';
        cell.style.color = 'white';
        cell.style.fontWeight = 'bold';
        
        // Create connector if there's a previous cell
        if (prevX !== null && prevY !== null) {
          createPathConnector(prevX, prevY, x, y);
        }
      } else {
        cell.classList.add('ring-1', 'ring-yellow-400');
      }
    }
  }

  function clearHighlights() {
    // Remove all connectors
    const connectors = document.querySelectorAll('.path-connector');
    connectors.forEach(connector => connector.remove());
    
    // Remove cell highlights
    Array.from(gridView.children).forEach(cell => {
      cell.classList.remove('path-cell', 'ring-1', 'ring-2', 'ring-4', 'ring-yellow-400', 'ring-blue-500');
      // Reset inline background styles
      cell.style.backgroundColor = '';
      cell.style.color = '';
      cell.style.fontWeight = '';
      
      // Re-apply radiation class colors
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      const value = grid[row][col];
      cell.className = `grid-cell ${getRadiationClass(value)} flex items-center justify-center font-medium h-12 w-full rounded-md relative`;
      
      // Re-add highlighting for start and end positions
      if (row === 0 && col === 0) {
        cell.classList.add('ring-2', 'ring-blue-500');
      }
      
      if (row === grid.length-1 && col === grid[0].length-1) {
        cell.classList.add('ring-2', 'ring-green-500');
      }
    });
  }

  function startAnimation() {
    if (!path.length) return;
    pauseAnimation();
    
    if (currentStep >= path.length) {
      currentStep = 0;
      clearHighlights();
    }
    
    isAnimating = true;
    const speed = 1100 - (animationSpeed.value * 100); // Convert 1-10 to milliseconds
    
    animationInterval = setInterval(() => {
      if (currentStep < path.length) {
        if (currentStep === 0) clearHighlights();
        
        const pos = path[currentStep];
        const prevPos = currentStep > 0 ? path[currentStep - 1] : null;
        
        highlightCell(
          pos.x, 
          pos.y, 
          true, 
          prevPos ? prevPos.x : null, 
          prevPos ? prevPos.y : null
        );
        
        currentStep++;
      } else {
        pauseAnimation();
      }
    }, speed);
  }

  function pauseAnimation() {
    isAnimating = false;
    clearInterval(animationInterval);
  }

  function stepAnimation() {
    pauseAnimation();
    
    if (!path.length) return;
    
    if (currentStep >= path.length) {
      currentStep = 0;
      clearHighlights();
    }
    
    const pos = path[currentStep];
    const prevPos = currentStep > 0 ? path[currentStep - 1] : null;
    
    highlightCell(
      pos.x, 
      pos.y, 
      true, 
      prevPos ? prevPos.x : null, 
      prevPos ? prevPos.y : null
    );
    
    currentStep++;
  }
});
</script>
</body>
</html>